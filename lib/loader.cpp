/* loader.cpp
 * Copyright (C) 2023 John Jekel and Nick Chan
 * See the LICENSE file at the root of the project for licensing info.
 *
 * Code for loading RISC-V binaries into memory
 *
*/

/* Constants And Defines */

//TODO

/* Includes */

#include "loader.h"

#include "emulator.h"

#include <fstream>
#include <string>

using namespace irve::internal;

/* Types */

//TODO

/* Variables */

//TODO

/* Static Function Declarations */

//TODO

/* Function Implementations */

//Verilog Hex format (32-bit words) + Backwards compatibility w/ previous file format
void loader::load_verilog_32(emulator_t& emulator, const char* filename) {
    //Open the image file
    std::fstream fin = std::fstream(filename);
    assert(fin && "Failed to open memory image file");

    //Read the file token by token
    word_t addr = 0;
    std::string token;
    while (fin >> token) {
        assert((token.length() != 0) && "This should never happen");
        if (token.at(0) == '@') {//New address (ASSUMING 32-BIT WORDS)
            std::string new_addr_str = token.substr(1);
            assert((new_addr_str.length() == 8) && "Memory image file is not formatted correctly (bad address)");
            addr.u = std::stoul(new_addr_str, nullptr, 16);
            addr *= 4;//This is a word address, not a byte address, so multiply by 4
            assert(((addr.u % 4) == 0) && "Memory image file is not formatted correctly (address not word aligned)");//TODO as it turns out, this is not a requirement
        } else {//New data word (32-bit, could be an instruction or data)
            //assert((token.length() == 8) && "Memory image file is not formatted correctly");
            //TODO sometimes there are tokens that are not 8 characters long generated by objcopy! Figure out the proper way to handle this
            
            //The data word this token represents
            word_t data_word = 0;
            
            //For each hex digit in the token
            for (uint32_t i = 0; i < token.length(); ++i) {
                //Grab the digit
                char c = (char)std::toupper(token[i]);

                //Turn it into a numeric value
                word_t hex = 0;
                if ((c > 47) && (c < 58)) {
                    hex = c - 48;
                } else if ((c > 64) && (c < 71)) {
                    hex = c - 55;
                } else {
                    assert(0 && "Invalid character in memory image file");
                }

                //Or it into the data word in the correct position
                hex <<= (28 - (4 * i));
                data_word |= hex;
            }

            //Write the data word to memory and increment the address to the next word
            emulator.mem_write(addr, 0b010, data_word);
            addr += 4;
        }
    }
}

/* Static Function Implementations */

//TODO
