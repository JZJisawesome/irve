/* main.cpp
 * Copyright (C) 2023 John Jekel and Nick Chan
 * See the LICENSE file at the root of the project for licensing info.
 *
 * IRVE - The Inextensible RISC-V Emulator
 *
 * Entry point
 *
*/

/* Constants and Defines */

#define TESTFILES_DIR "testfiles/compiled/"

/* Includes */

#include <cassert>
#include <iostream>
#include <fstream>
#include <string>

#include "emulator.h"
#include "common.h"

#if __has_include("cmake_config.h")
#include "cmake_config.h"
#else
#define VERSION_STRING "IRVE (Version Unknown)"
#define DISABLE_LOGGING 0
#endif

#define INST_COUNT 0
#include "logging.h"

/* Static Function Declarations */

static void load_memory_image(emulator_t& emulator, const char* filename);

/* Function Implementations */

int main(int argc, char** argv) {
#if DISABLE_LOGGING
    //Only print this
    std::cerr << "Starting " << VERSION_STRING << std::endl;
    std::cerr << "Copyright (C) 2023 John Jekel and Nick Chan" << std::endl;
    std::cerr << "See the LICENSE file at the root of the project for licensing info." << std::endl;
#endif

    irvelog(0, "\x1b[1mStarting \x1b[94m" VERSION_STRING "\x1b[0m");
    irvelog(0, "\x1b[1m\x1b[94m ___ ______     _______ \x1b[0m");
    irvelog(0, "\x1b[1m\x1b[94m|_ _|  _ \\ \\   / / ____|\x1b[0m");
    irvelog(0, "\x1b[1m\x1b[94m | || |_) \\ \\ / /|  _|  \x1b[0m"); 
    irvelog(0, "\x1b[1m\x1b[94m | ||  _ < \\ V / | |___ \x1b[0m");
    irvelog(0, "\x1b[1m\x1b[94m|___|_| \\_\\ \\_/  |_____|\x1b[0m");
    irvelog(0, "");
    irvelog(0, "\x1b[1mThe Inextensible RISC-V Emulator\x1b[0m");
    irvelog(0, "\x1b[1mCopyright (C) 2023 \x1b[95mJohn Jekel\x1b[37m and \x1b[92mNick Chan\x1b[0m");
    irvelog(0, "\x1b[90mSee the LICENSE file at the root of the project for licensing info.\x1b[0m");
    irvelog(0, "------------------------------------------------------------------------");
    irvelog(0, "");
    irvelog(0, "");
   
    irvelog(0, "Initializing emulator...");
#undef INST_COUNT
#define INST_COUNT emulator.get_inst_count()
    emulator_t emulator;

    if (argc < 2) {
        irvelog(0, "No memory image file specified. Starting with empty memory.");
    } else {
        assert(argc == 2 && "Too many arguments for now");//TODO remove this if we need in the future
        load_memory_image(emulator, argv[1]);
    }

    while (emulator.tick());//Tick the emulator until we get an exit request

    irvelog(0, "\x1b[1mIRVE is shutting down. Bye bye!\x1b[0m");
    return 0;
}

/* Static Function Implementations */

//Verilog Hex format (32-bit words) + Backwards compatibility w/ previous file format
static void load_memory_image(emulator_t& emulator, const char* filename) {
    irvelog(0, "Loading memory image from file \"%s\"", filename);

    //Locate and open the image file 
    std::string mem_file = filename;
    //A testfile name rather than a path, so prepend the testfiles directory
    if (mem_file.find(TESTFILES_DIR) == std::string::npos) {
        mem_file = TESTFILES_DIR + mem_file;
    }
    std::fstream fin = std::fstream(mem_file);
    assert(fin && "Failed to open memory image file");

    //Read the file token by token
    word_t addr = 0;
    std::string token;
    while (fin >> token) {
        assert((token.length() != 0) && "This should never happen");
        if (token.at(0) == '@') {//New address (ASSUMING 32-BIT WORDS)
            std::string new_addr_str = token.substr(1);
            assert((new_addr_str.length() == 8) && "Memory image file is not formatted correctly (bad address)");
            addr.u = std::stoul(new_addr_str, nullptr, 16);
            addr *= 4;//This is a word address, not a byte address, so multiply by 4
            assert(((addr.u % 4) == 0) && "Memory image file is not formatted correctly (address not word aligned)");//TODO as it turns out, this is not a requirement
        } else {//New data word (32-bit, could be an instruction or data)
            //assert((token.length() == 8) && "Memory image file is not formatted correctly");
            //TODO sometimes there are tokens that are not 8 characters long generated by objcopy! Figure out the proper way to handle this
            
            //The data word this token represents
            word_t data_word = 0;
            
            //For each hex digit in the token
            for (uint32_t i = 0; i < token.length(); ++i) {
                //Grab the digit
                char c = (char)std::toupper(token[i]);

                //Turn it into a numeric value
                word_t hex = 0;
                if ((c > 47) && (c < 58)) {
                    hex = c - 48;
                } else if ((c > 64) && (c < 71)) {
                    hex = c - 55;
                } else {
                    assert(0 && "Invalid character in memory image file");
                }

                //Or it into the data word in the correct position
                hex <<= (28 - (4 * i));
                data_word |= hex;
            }

            //Write the data word to memory and increment the address to the next word
            emulator.mem_write(addr, 0b010, data_word);
            addr += 4;
        }
    }
}
