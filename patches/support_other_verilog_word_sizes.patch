diff --git a/src/main.cpp b/src/main.cpp
index e5e25ea..5a1cdd3 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -55,6 +55,7 @@ int main(int argc, char** argv) {
 /* Static Function Implementations */
 
 //Verilog Hex format (32-bit words) + Backwards compatibility w/ previous file format
+//TODO be smart and detect the word size to allow for 8-bit "regular" verilog hex files
 static void load_memory_image(emulator_t& emulator, const char* filename) {
     irvelog(0, "Loading memory image from file \"%s\"", filename);
 
@@ -68,7 +69,9 @@ static void load_memory_image(emulator_t& emulator, const char* filename) {
     assert(fin && "Failed to open memory image file");
 
     //Read the file token by token
-    uint32_t addr = 0;
+    uint32_t guessed_width = 0;//To support different word sizes
+
+    uint32_t addr = 0;//Start at address 0 for backwards compatibility
     std::string token;
     while (fin >> token) {
         assert((token.length() != 0) && "This should never happen");
@@ -76,36 +79,47 @@ static void load_memory_image(emulator_t& emulator, const char* filename) {
             std::string new_addr_str = token.substr(1);
             assert((new_addr_str.length() == 8) && "Memory image file is not formatted correctly (bad address)");
             addr = std::stoul(new_addr_str, nullptr, 16);
-            assert(((addr % 4) == 0) && "Memory image file is not formatted correctly (address not word aligned)");//TODO as it turns out, this is not a requirement
+            if (guessed_width) {
+                assert(((addr % guessed_width) == 0) && "Memory image file is not formatted correctly (address not word aligned)");
+            }
         } else {//New data word (32-bit, could be an instruction or data)
-            assert((token.length() == 8) && "Memory image file is not formatted correctly");
-            
-            //The data word this token represents
-            uint32_t data_word = 0;
+            if (guessed_width) {
+                assert((token.length() == (guessed_width * 2)) && "Memory image file is not formatted correctly (inconsistent word size)");
+            } else {
+                assert((token.length() % 2 == 0) && "Memory image file is not formatted correctly (odd number of hex digits)");
+                guessed_width = token.length() / 2;
+            }
             
-            //For each hex digit in the token
-            for (std::size_t i = 0; i < 8; ++i) {
-                //Grab the digit
-                char c = (char)std::toupper(token[i]);
-
-                //Turn it into a numeric value
-                uint32_t hex = 0;
-                if ((c > 47) && (c < 58)) {
-                    hex = c - 48;
-                } else if ((c > 64) && (c < 71)) {
-                    hex = c - 55;
-                } else {
-                    assert(0 && "Invalid character in memory image file");
+            if (guessed_width == 8) {
+                //The data word this token represents
+                uint32_t data_word = 0;
+                
+                //For each hex digit in the token
+                for (std::size_t i = 0; i < 8; ++i) {
+                    //Grab the digit
+                    char c = (char)std::toupper(token[i]);
+
+                    //Turn it into a numeric value
+                    uint32_t hex = 0;
+                    if ((c > 47) && (c < 58)) {
+                        hex = c - 48;
+                    } else if ((c > 64) && (c < 71)) {
+                        hex = c - 55;
+                    } else {
+                        assert(0 && "Invalid character in memory image file");
+                    }
+
+                    //Or it into the data word in the correct position
+                    hex <<= (28 - (4 * i));
+                    data_word |= hex;
                 }
 
-                //Or it into the data word in the correct position
-                hex <<= (28 - (4 * i));
-                data_word |= hex;
+                //Write the data word to memory and increment the address to the next word
+                emulator.mem_write(addr, 0b010, data_word);
+                addr += 4;
+            } else {
+                //TODO support other word sizes
             }
-
-            //Write the data word to memory and increment the address to the next word
-            emulator.mem_write(addr, 0b010, data_word);
-            addr += 4;
         }
     }
 }
